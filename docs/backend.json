{
  "entities": {
    "Store": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Store",
      "type": "object",
      "description": "Represents a store location.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Store entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the store."
        },
        "latitude": {
          "type": "number",
          "description": "The latitude coordinate of the store's location."
        },
        "longitude": {
          "type": "number",
          "description": "The longitude coordinate of the store's location."
        }
      },
      "required": [
        "id",
        "name",
        "latitude",
        "longitude"
      ]
    },
    "StoreCrew": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StoreCrew",
      "type": "object",
      "description": "Represents a store crew member.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the StoreCrew entity."
        },
        "storeId": {
          "type": "string",
          "description": "Reference to Store. (Relationship: Store 1:N StoreCrew)"
        },
        "firstName": {
          "type": "string",
          "description": "The first name of the store crew member."
        },
        "lastName": {
          "type": "string",
          "description": "The last name of the store crew member."
        },
        "contactNumber": {
          "type": "string",
          "description": "The contact number of the store crew member."
        }
      },
      "required": [
        "id",
        "storeId",
        "firstName",
        "lastName",
        "contactNumber"
      ]
    },
    "AttendanceLog": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AttendanceLog",
      "type": "object",
      "description": "Represents an attendance log entry for a store crew member.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the AttendanceLog entity."
        },
        "storeCrewId": {
          "type": "string",
          "description": "Reference to StoreCrew. (Relationship: StoreCrew 1:N AttendanceLog)"
        },
        "clockInTime": {
          "type": "string",
          "description": "The date and time when the store crew member clocked in.",
          "format": "date-time"
        },
        "clockOutTime": {
          "type": "string",
          "description": "The date and time when the store crew member clocked out.",
          "format": "date-time"
        },
        "clockInLatitude": {
          "type": "number",
          "description": "The latitude when clocking in."
        },
        "clockInLongitude": {
          "type": "number",
          "description": "The longitude when clocking in."
        },
        "clockOutLatitude": {
          "type": "number",
          "description": "The latitude when clocking out."
        },
        "clockOutLongitude": {
          "type": "number",
          "description": "The longitude when clocking out."
        }
      },
      "required": [
        "id",
        "storeCrewId",
        "clockInTime"
      ]
    },
    "BroadcastMessage": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BroadcastMessage",
      "type": "object",
      "description": "Represents a broadcast message sent to store crew members.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the BroadcastMessage entity."
        },
        "message": {
          "type": "string",
          "description": "The content of the broadcast message."
        },
        "timestamp": {
          "type": "string",
          "description": "The date and time when the message was sent.",
          "format": "date-time"
        },
        "storeIds": {
          "type": "array",
          "description": "References to Stores that will receive the Broadcast Message. If the array is empty, it indicates that all stores will receive it. (Relationship: Store N:N BroadcastMessage)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "message",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/roles_admin/{uid}",
        "definition": {
          "entityName": "adminRole",
          "schema": {
            "$ref": "#/backend/entities/adminRole"
          },
          "description": "Collection to store admin roles. Presence of a document for a UID indicates admin access.",
          "params": [
            {
              "name": "uid",
              "description": "The Firebase UID of the admin user."
            }
          ]
        }
      },
      {
        "path": "/stores/{storeId}",
        "definition": {
          "entityName": "Store",
          "schema": {
            "$ref": "#/backend/entities/Store"
          },
          "description": "Collection to store store information. Admins can create and manage stores.",
          "params": [
            {
              "name": "storeId",
              "description": "The unique identifier of the store."
            }
          ]
        }
      },
      {
        "path": "/stores/{storeId}/crew/{crewId}",
        "definition": {
          "entityName": "StoreCrew",
          "schema": {
            "$ref": "#/backend/entities/StoreCrew"
          },
          "description": "Collection to store store crew information. Enforces path-based ownership for security.",
          "params": [
            {
              "name": "storeId",
              "description": "The unique identifier of the store."
            },
            {
              "name": "crewId",
              "description": "The unique identifier of the store crew member."
            }
          ]
        }
      },
      {
        "path": "/stores/{storeId}/crew/{crewId}/attendance/{attendanceId}",
        "definition": {
          "entityName": "AttendanceLog",
          "schema": {
            "$ref": "#/backend/entities/AttendanceLog"
          },
          "description": "Collection to store attendance logs. Enforces path-based ownership; includes denormalized 'storeId' for authorization independence.",
          "params": [
            {
              "name": "storeId",
              "description": "The unique identifier of the store."
            },
            {
              "name": "crewId",
              "description": "The unique identifier of the store crew member."
            },
            {
              "name": "attendanceId",
              "description": "The unique identifier of the attendance log entry."
            }
          ]
        }
      },
      {
        "path": "/broadcasts/{broadcastId}",
        "definition": {
          "entityName": "BroadcastMessage",
          "schema": {
            "$ref": "#/backend/entities/BroadcastMessage"
          },
          "description": "Collection for broadcast messages. 'storeIds' array indicates target stores.",
          "params": [
            {
              "name": "broadcastId",
              "description": "The unique identifier of the broadcast message."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support the CrewClock application's requirements, focusing on attendances, store management, crew management, and broadcast messaging. It prioritizes authorization independence, clarity, and scalability. \n\n**Authorization Independence and QAPs:** Authorization independence is achieved by avoiding `get()` calls in security rules. The structure ensures QAPs by segregating data based on access needs and using membership maps where necessary.\n\n**Admin Roles:** Admin privileges are managed through the `/roles_admin/{uid}` collection. The existence of a document in this collection grants admin access.\n\n**Stores:** Store data is stored in the `/stores/{storeId}` collection. This collection will store information about each store, such as its name and location. Admins can create and manage stores.\n\n**Store Crews:** Store crew data is stored in the `/stores/{storeId}/crew/{crewId}` collection. This structure enforces path-based ownership, as each crew member is associated with a specific store. This is essential for authorization, enabling rules like 'only admins or the store crew themselves can access their data'.\n\n**Attendance Logs:** Attendance logs are stored in `/stores/{storeId}/crew/{crewId}/attendance/{attendanceId}`. This nested structure continues the path-based ownership model. Each attendance record is tied to a specific crew member and store, ensuring clear ownership and simplified security rules.\n\n**Broadcast Messages:** Broadcast messages are stored in the `/broadcasts/{broadcastId}` collection. The `storeIds` array indicates which stores should receive the message. Security rules can ensure only admins can create broadcast messages. To support QAPs (rules are not filters), the messages are sent to *all* stores unless `storeIds` is present and non-empty. Store crew can only view messages if the message has the store id on the `storeIds` array.\n\n**Denormalization:** \nTo ensure Authorization Independence, the `storeId` is repeated on the attendance log. This avoids having to do a `get()` request to the `crew` document to verify its membership. It also allows for atomic creation.\nFor Broadcast Messages, each crew document has a field `allowedBroadcasts`. When creating a new broadcast, a backend process will update each affected Crew documents `allowedBroadcasts` field to contain the broadcast id. This allows each crew member to only be able to see allowed broadcasts in the UI."
  }
}